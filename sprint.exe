package main

import (
	"context"
	"crypto/tls"
	"encoding/json"
	"fmt"
	"io"
	"log"
	"net"
	"net/http"
	"os"
	"sync"
	"time"

	"github.com/gorilla/websocket"
	zmq "github.com/pebbe/zmq4"
)

type Config struct {
	LicenseKey  string `json:"license_key"`
	Tier        string `json:"tier"`
	MetricsURL  string `json:"metrics_url"`
	ZMQ         string `json:"zmq"`
	APIBase     string `json:"api_base"`
}

type License struct {
	Valid      bool     `json:"valid"`
	Tier       string   `json:"tier"`
	BlockLimit int      `json:"block_limit"`
	Peers      []string `json:"peers"`
}

type Metrics struct {
	BlockHash    string  `json:"block_hash"`
	Latency      float64 `json:"latency_ms"`
	PeerCount    int     `json:"peer_count"`
	Timestamp    int64   `json:"timestamp"`
	LicenseKey   string  `json:"license_key"`
}

type Sprint struct {
	config      Config
	license     License
	peers       []net.Conn
	metrics     []Metrics
	blocksSent  int
	mu          sync.RWMutex
	ctx         context.Context
	cancel      context.CancelFunc
}

func main() {
	sprint := &Sprint{}
	sprint.ctx, sprint.cancel = context.WithCancel(context.Background())
	
	if err := sprint.LoadConfig(); err != nil {
		log.Fatal("Config error:", err)
	}
	
	if err := sprint.ValidateLicense(); err != nil {
		log.Fatal("License error:", err)
	}
	
	go sprint.StartWebDashboard()
	go sprint.StartZMQListener()
	go sprint.ConnectToPeers()
	go sprint.StartMetricsReporter()
	
	log.Println("üöÄ Bitcoin Sprint running...")
	log.Printf("üìä Dashboard: http://localhost:8080")
	log.Printf("‚ö° Tier: %s", sprint.license.Tier)
	
	select {}
}

func (s *Sprint) LoadConfig() error {
	// Create default config if doesn't exist
	if _, err := os.Stat("config.json"); os.IsNotExist(err) {
		defaultConfig := Config{
			LicenseKey: "",
			Tier:       "free",
			MetricsURL: "https://api.bitcoinsprint.com/metrics",
			ZMQ:        "tcp://127.0.0.1:28332",
			APIBase:    "https://api.bitcoinsprint.com",
		}
		data, _ := json.MarshalIndent(defaultConfig, "", "  ")
		os.WriteFile("config.json", data, 0644)
		s.config = defaultConfig
		return nil
	}
	
	data, err := os.ReadFile("config.json")
	if err != nil {
		return err
	}
	
	return json.Unmarshal(data, &s.config)
}

func (s *Sprint) ValidateLicense() error {
	if s.config.LicenseKey == "" {
		s.license = License{
			Valid:      true,
			Tier:       "free",
			BlockLimit: 5,
			Peers:      []string{}, // Free tier gets basic peers
		}
		return nil
	}
	
	client := &http.Client{Timeout: 10 * time.Second}
	url := fmt.Sprintf("%s/license/%s", s.config.APIBase, s.config.LicenseKey)
	
	resp, err := client.Get(url)
	if err != nil {
		return fmt.Errorf("license validation failed: %w", err)
	}
	defer resp.Body.Close()
	
	if resp.StatusCode != 200 {
		return fmt.Errorf("invalid license key")
	}
	
	return json.NewDecoder(resp.Body).Decode(&s.license)
}

func (s *Sprint) StartZMQListener() {
	socket, err := zmq.NewSocket(zmq.SUB)
	if err != nil {
		log.Fatal("ZMQ error:", err)
	}
	defer socket.Close()
	
	socket.Connect(s.config.ZMQ)
	socket.SetSubscribe("hashblock")
	
	for {
		select {
		case <-s.ctx.Done():
			return
		default:
			msg, err := socket.RecvMessage(0)
			if err != nil {
				log.Printf("ZMQ recv error: %v", err)
				continue
			}
			
			if len(msg) >= 2 && msg[0] == "hashblock" {
				blockHash := fmt.Sprintf("%x", msg[1])
				s.OnNewBlock(blockHash)
			}
		}
	}
}

func (s *Sprint) OnNewBlock(blockHash string) {
	s.mu.Lock()
	defer s.mu.Unlock()
	
	// Check block limit for free tier
	if s.license.Tier == "free" && s.blocksSent >= s.license.BlockLimit {
		log.Printf("‚è∏Ô∏è  Block limit reached for free tier (5/day)")
		return
	}
	
	start := time.Now()
	
	// Sprint the block to connected peers
	sent := s.SprintBlock(blockHash)
	
	latency := float64(time.Since(start).Nanoseconds()) / 1e6 // Convert to ms
	
	// Record metrics
	metric := Metrics{
		BlockHash:  blockHash,
		Latency:    latency,
		PeerCount:  sent,
		Timestamp:  time.Now().Unix(),
		LicenseKey: s.config.LicenseKey,
	}
	
	s.metrics = append(s.metrics, metric)
	s.blocksSent++
	
	log.Printf("‚ö° Block %s sprinted in %.1fms to %d peers", 
		blockHash[:8], latency, sent)
}

func (s *Sprint) SprintBlock(blockHash string) int {
	if len(s.peers) == 0 {
		return 0
	}
	
	// Simple block announcement message (Bitcoin P2P protocol)
	announcement := fmt.Sprintf("inv:block:%s", blockHash)
	sent := 0
	
	for _, peer := range s.peers {
		if peer != nil {
			peer.SetWriteDeadline(time.Now().Add(100 * time.Millisecond))
			if _, err := peer.Write([]byte(announcement)); err == nil {
				sent++
			}
		}
	}
	
	return sent
}

func (s *Sprint) ConnectToPeers() {
	// Get optimal peers for user's tier
	peers := s.GetOptimalPeers()
	
	for _, peerAddr := range peers {
		go s.ConnectToPeer(peerAddr)
	}
	
	// Reconnection loop
	ticker := time.NewTicker(30 * time.Second)
	defer ticker.Stop()
	
	for {
		select {
		case <-s.ctx.Done():
			return
		case <-ticker.C:
			s.MaintainConnections()
		}
	}
}

func (s *Sprint) GetOptimalPeers() []string {
	// Default fast peers for free tier
	defaultPeers := []string{
		"seed.bitcoin.sipa.be:8333",
		"dnsseed.bluematt.me:8333",
		"seed.bitcoinstats.com:8333",
	}
	
	if s.license.Tier == "free" {
		return defaultPeers[:2] // Limit connections for free
	}
	
	// For paid tiers, get premium peers from API
	if len(s.license.Peers) > 0 {
		return s.license.Peers
	}
	
	return defaultPeers
}

func (s *Sprint) ConnectToPeer(address string) {
	s.mu.Lock()
	defer s.mu.Unlock()
	
	conn, err := net.DialTimeout("tcp", address, 5*time.Second)
	if err != nil {
		log.Printf("Failed to connect to %s: %v", address, err)
		return
	}
	
	// Set TCP_NODELAY for low latency
	if tcpConn, ok := conn.(*net.TCPConn); ok {
		tcpConn.SetNoDelay(true)
		tcpConn.SetKeepAlive(true)
	}
	
	s.peers = append(s.peers, conn)
	log.Printf("üîó Connected to peer: %s", address)
}

func (s *Sprint) MaintainConnections() {
	s.mu.Lock()
	defer s.mu.Unlock()
	
	activePeers := make([]net.Conn, 0)
	
	for _, peer := range s.peers {
		if peer != nil {
			// Test connection with a simple write
			peer.SetWriteDeadline(time.Now().Add(1 * time.Second))
			if _, err := peer.Write([]byte("ping")); err == nil {
				activePeers = append(activePeers, peer)
			} else {
				peer.Close()
			}
		}
	}
	
	s.peers = activePeers
	log.Printf("üîÑ Active peers: %d", len(s.peers))
}

func (s *Sprint) StartWebDashboard() {
	mux := http.NewServeMux()
	
	mux.HandleFunc("/", s.HandleDashboard)
	mux.HandleFunc("/metrics", s.HandleMetrics)
	mux.HandleFunc("/ws", s.HandleWebSocket)
	
	server := &http.Server{
		Addr:    ":8080",
		Handler: mux,
	}
	
	log.Fatal(server.ListenAndServe())
}

func (s *Sprint) HandleDashboard(w http.ResponseWriter, r *http.Request) {
	s.mu.RLock()
	defer s.mu.RUnlock()
	
	html := `<!DOCTYPE html>
<html>
<head>
    <title>Bitcoin Sprint Dashboard</title>
    <style>
        body { font-family: monospace; background: #0a0a0a; color: #00ff00; padding: 20px; }
        .metric { margin: 10px 0; font-size: 18px; }
        .fast { color: #00ff00; }
        .slow { color: #ff6600; }
    </style>
</head>
<body>
    <h1>‚ö° Bitcoin Sprint Dashboard</h1>
    <div class="metric">Tier: <strong>%s</strong></div>
    <div class="metric">Blocks Sprinted: <strong>%d</strong></div>
    <div class="metric">Active Peers: <strong>%d</strong></div>
    <div class="metric">Status: <strong class="fast">ACTIVE</strong></div>
    
    <h2>Recent Performance</h2>
    %s
</body>
</html>`
	
	recentMetrics := ""
	metricsCount := len(s.metrics)
	start := 0
	if metricsCount > 10 {
		start = metricsCount - 10
	}
	
	for i := start; i < metricsCount; i++ {
		m := s.metrics[i]
		class := "fast"
		if m.Latency > 100 {
			class = "slow"
		}
		recentMetrics += fmt.Sprintf(
			`<div class="metric %s">Block %s: %.1fms (%d peers)</div>`,
			class, m.BlockHash[:8], m.Latency, m.PeerCount,
		)
	}
	
	fmt.Fprintf(w, html, s.license.Tier, s.blocksSent, len(s.peers), recentMetrics)
}

func (s *Sprint) HandleMetrics(w http.ResponseWriter, r *http.Request) {
	s.mu.RLock()
	defer s.mu.RUnlock()
	
	w.Header().Set("Content-Type", "application/json")
	json.NewEncoder(w).Encode(map[string]interface{}{
		"tier":          s.license.Tier,
		"blocks_sent":   s.blocksSent,
		"active_peers":  len(s.peers),
		"recent_metrics": s.metrics,
	})
}

var upgrader = websocket.Upgrader{
	CheckOrigin: func(r *http.Request) bool { return true },
}

func (s *Sprint) HandleWebSocket(w http.ResponseWriter, r *http.Request) {
	conn, err := upgrader.Upgrade(w, r, nil)
	if err != nil {
		log.Printf("WebSocket upgrade error: %v", err)
		return
	}
	defer conn.Close()
	
	// Send real-time updates
	ticker := time.NewTicker(1 * time.Second)
	defer ticker.Stop()
	
	for {
		select {
		case <-ticker.C:
			s.mu.RLock()
			data := map[string]interface{}{
				"peers":       len(s.peers),
				"blocks_sent": s.blocksSent,
				"timestamp":   time.Now().Unix(),
			}
			s.mu.RUnlock()
			
			if err := conn.WriteJSON(data); err != nil {
				return
			}
		}
	}
}

func (s *Sprint) StartMetricsReporter() {
	if s.config.LicenseKey == "" {
		return // Don't report metrics for free tier
	}
	
	ticker := time.NewTicker(5 * time.Minute)
	defer ticker.Stop()
	
	for {
		select {
		case <-s.ctx.Done():
			return
		case <-ticker.C:
			s.ReportMetrics()
		}
	}
}

func (s *Sprint) ReportMetrics() {
	s.mu.RLock()
	if len(s.metrics) == 0 {
		s.mu.RUnlock()
		return
	}
	
	// Send recent metrics to cloud
	payload, _ := json.Marshal(s.metrics)
	s.mu.RUnlock()
	
	client := &http.Client{
		Timeout: 10 * time.Second,
		Transport: &http.Transport{
			TLSClientConfig: &tls.Config{InsecureSkipVerify: false},
		},
	}
	
	req, _ := http.NewRequest("POST", s.config.MetricsURL, 
		io.NopCloser(bytes.NewReader(payload)))
	req.Header.Set("Content-Type", "application/json")
	req.Header.Set("Authorization", "Bearer "+s.config.LicenseKey)
	
	resp, err := client.Do(req)
	if err != nil {
		log.Printf("Metrics upload failed: %v", err)
		return
	}
	resp.Body.Close()
	
	// Clear sent metrics
	s.mu.Lock()
	s.metrics = s.metrics[:0]
	s.mu.Unlock()
}