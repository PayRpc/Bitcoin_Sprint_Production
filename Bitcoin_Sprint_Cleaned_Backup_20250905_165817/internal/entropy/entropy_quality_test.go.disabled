// Package entropy provides statistical tests for entropy quality
package entropy

import (
	"math"
	"math/big"
	"testing"
)

// bitCount counts the number of 1 bits in data
func bitCount(data []byte) int {
	count := 0
	for _, b := range data {
		count += big.NewInt(int64(b)).BitLen()
	}
	return count
}

// TestEntropyStatisticalProperties tests basic statistical properties of entropy
func TestEntropyStatisticalProperties(t *testing.T) {
	totalSamples := 1000
	ones := 0
	bits := 0

	for i := 0; i < totalSamples; i++ {
		e := cgobindings.FastEntropy()
		for _, b := range e {
			for bit := 0; bit < 8; bit++ {
				if (b>>bit)&1 == 1 {
					ones++
				}
				bits++
			}
		}
	}

	ratio := float64(ones) / float64(bits)
	if ratio < 0.45 || ratio > 0.55 {
		t.Errorf("Entropy bias detected: ratio=%.3f, expected ~0.5", ratio)
	}

	t.Logf("Statistical test results:")
	t.Logf("  Total bits sampled: %d", bits)
	t.Logf("  Ones count: %d", ones)
	t.Logf("  Zeros count: %d", bits-ones)
	t.Logf("  Ratio: %.3f", ratio)
}

// TestEntropyDistribution tests the distribution of entropy values
func TestEntropyDistribution(t *testing.T) {
	samples := 1000
	byteCounts := make(map[byte]int)

	for i := 0; i < samples; i++ {
		e := cgobindings.FastEntropy()
		for _, b := range e {
			byteCounts[b]++
		}
	}

	totalBytes := samples * 32
	expectedCount := totalBytes / 256

	t.Logf("Byte distribution test (expected ~%.1f per byte):", float64(expectedCount))

	// Check that no byte value is too rare or too common
	minExpected := int(float64(expectedCount) * 0.5)  // Allow 50% variance
	maxExpected := int(float64(expectedCount) * 1.5)

	outliers := 0
	for b := 0; b < 256; b++ {
		count := byteCounts[byte(b)]
		if count < int(minExpected) || count > int(maxExpected) {
			outliers++
			if outliers <= 5 { // Only log first few outliers
				t.Logf("  Byte 0x%02x: %d (outside expected range)", b, count)
			}
		}
	}

	if outliers > 10 {
		t.Errorf("Too many outlier byte values: %d (expected < 10)", outliers)
	} else {
		t.Logf("  Outliers: %d (acceptable)", outliers)
	}
}

// TestEntropyRuns tests for runs of identical bits (should be minimal)
func TestEntropyRuns(t *testing.T) {
	samples := 100
	maxRunLength := 0
	totalRuns := 0

	for i := 0; i < samples; i++ {
		e := cgobindings.FastEntropy()
		currentBit := (e[0] >> 7) & 1
		currentRun := 1

		for _, b := range e {
			for bit := 7; bit >= 0; bit-- {
				bitValue := (b >> bit) & 1
				if bitValue == currentBit {
					currentRun++
				} else {
					if currentRun > maxRunLength {
						maxRunLength = currentRun
					}
					totalRuns++
					currentBit = bitValue
					currentRun = 1
				}
			}
		}
	}

	t.Logf("Runs test results:")
	t.Logf("  Maximum run length: %d", maxRunLength)
	t.Logf("  Total runs: %d", totalRuns)

	// Long runs indicate poor randomness
	if maxRunLength > 20 {
		t.Errorf("Maximum run length too high: %d (expected < 20)", maxRunLength)
	}
}

// TestEntropyChiSquare performs a chi-square test for uniformity
func TestEntropyChiSquare(t *testing.T) {
	samples := 1000
	byteCounts := make(map[byte]int)

	// Collect byte frequencies
	for i := 0; i < samples; i++ {
		e := cgobindings.FastEntropy()
		for _, b := range e {
			byteCounts[b]++
		}
	}

	totalBytes := samples * 32
	expectedCount := float64(totalBytes) / 256.0

	// Calculate chi-square statistic
	chiSquare := 0.0
	for b := 0; b < 256; b++ {
		observed := float64(byteCounts[byte(b)])
		expected := expectedCount
		if observed > 0 {
			chiSquare += math.Pow(observed-expected, 2) / expected
		}
	}

	// For 255 degrees of freedom (256 categories - 1), chi-square should be around 255
	// We allow a reasonable range for randomness
	lowerBound := 200.0
	upperBound := 350.0

	t.Logf("Chi-square test results:")
	t.Logf("  Chi-square statistic: %.2f", chiSquare)
	t.Logf("  Expected range: [%.0f, %.0f]", lowerBound, upperBound)

	if chiSquare < lowerBound || chiSquare > upperBound {
		t.Errorf("Chi-square test failed: %.2f (outside acceptable range)", chiSquare)
	} else {
		t.Logf("  Result: PASS (within acceptable range)")
	}
}

// TestHybridEntropyHeadersInfluence tests that headers actually influence hybrid entropy
func TestHybridEntropyHeadersInfluence(t *testing.T) {
	baseHeaders := [][]byte{make([]byte, 80)}
	baseEntropy := cgobindings.HybridEntropy(baseHeaders)

	// Test with slightly different headers
	testCases := []struct {
		name     string
		headers  [][]byte
		expected bool // whether entropy should differ
	}{
		{"same headers", baseHeaders, false},
		{"different header", [][]byte{[]byte("different........................")}, true},
		{"empty headers", [][]byte{}, true},
		{"multiple headers", [][]byte{make([]byte, 80), make([]byte, 80)}, true},
	}

	for _, tc := range testCases {
		t.Run(tc.name, func(t *testing.T) {
			entropy := cgobindings.HybridEntropy(tc.headers)
			different := string(entropy) != string(baseEntropy)

			if different != tc.expected {
				t.Errorf("Expected entropy to %s headers, but got %s",
					map[bool]string{true: "differ with", false: "be same as"}[tc.expected],
					map[bool]string{true: "different", false: "same"}[different])
			}
		})
	}
}

// BenchmarkEntropyGeneration benchmarks entropy generation performance
func BenchmarkEntropyGeneration(b *testing.B) {
	b.Run("FastEntropy", func(b *testing.B) {
		for i := 0; i < b.N; i++ {
			_ = cgobindings.FastEntropy()
		}
	})

	b.Run("HybridEntropy", func(b *testing.B) {
		headers := [][]byte{make([]byte, 80)}
		for i := 0; i < b.N; i++ {
			_ = cgobindings.HybridEntropy(headers)
		}
	})
}
